/*
    File Name: ycalc.cup
    To Create: > java java_cup.Main < ycalc.cup
  */
    
    
  /* ----------------------Preliminary Declarations Section--------------------*/
    
  import java_cup.runtime.*;

  parser code {:
      TablaSimbolos tabla = new TablaSimbolos();
      AssemblerGenerator ag;
      Node RaizNode;
      public void report_error(String message, Object info) {
    
          StringBuffer m = new StringBuffer("Error");
    
          if (info instanceof java_cup.runtime.Symbol) {
              java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
    
              if (s.left >= 0) {                
                  m.append(" in line "+(s.left+1));   
                  if (s.right >= 0)                    
                      m.append(", column "+(s.right+1));
              }
          }
    
          m.append(" : "+message);
    
          System.err.println(m);
      }
    
      public void report_fatal_error(String message, Object info) {
          report_error(message, info);
          System.exit(1);
      }
  :};
    

    
  /* ------------Declaration of Terminals and Non Terminals Section----------- */
    

  terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN, AND, OR;
  terminal           RKEY, LKEY, VOID, MAIN, COMA, EQUAL, DOUBLEEQUAL, NOTEQUAL;
  terminal           INT,  FLOAT, BOOLEAN, STRING, IF, ELSE, WHILE, GREATER, LESS;
  terminal           LESSEQUAL, GREATEREQUAL, RETURN;

  terminal Integer NUMBER;
  terminal String ID;
  terminal Float FLOATNUM;
  terminal Boolean BOOLEAN_LIT;

  non terminal String tipo, comparison_expr;
  non terminal Node expr, expr_part, valor, asignacion, statement, if_statement, while_statement, condicion;
  non terminal Node func_section, main_block, func_list, program, expr_dcl_list, declaracion;
  non terminal Node func_decl, return_statement, func_call, param_list, arg_list;
  non terminal func, void_decl, main;
  non terminal params;


    

  /* -------------Precedence and Associatively of Terminals Section----------- */
    
  precedence left OR;
  precedence left AND;
  precedence left PLUS, MINUS;
  precedence left TIMES, DIVIDE;


  /* ----------------------------Grammar Section-------------------- */
    
    main ::= func_section:fs main_block:mb
            {: Node program = new Node(null, fs, mb, "program");
              System.out.println("Arbol");
              program.recorrer(tabla);
              program.getType(tabla);
              program.recorridoInterprete(tabla);
              ag = new AssemblerGenerator();
              String assemblerCode = ag.generateAssembler(program, tabla);
              System.out.println("\n--- Código Assembler ---\n" + assemblerCode);
              ag.saveToFile("salida.txt");
              RaizNode = program;
            :}
          | main_block:mb
            {: RaizNode = new Node(null, null, mb, "root");
              System.out.println("Arbol");
              RaizNode.recorrer(tabla);
              RaizNode.getType(tabla);
              RaizNode.recorridoInterprete(tabla);
              ag = new AssemblerGenerator();
              String assemblerCode = ag.generateAssembler(RaizNode, tabla);
              System.out.println("\n--- Código Assembler ---\n" + assemblerCode);
              ag.saveToFile("salida.txt");
            :}
          ;

  func_section ::= func_section:fs func_decl:fd
                   {: RESULT = new Node(null, fs, fd, "functions"); :}
                 | func_decl:fd
                   {: RESULT = fd; :}
                 ;

  func_decl ::= tipo:tp ID:id LPAREN params RPAREN LKEY program:pg RKEY
              {:
                tabla.Agregar(id, tp, "function");
                // CAMBIAR ESTA LÍNEA:
                RESULT = new Node(id, new Node(tp, "Leaf", tp), pg, "func_decl");
              :}
            | VOID ID:id LPAREN params RPAREN LKEY program:pg RKEY
              {:
                tabla.Agregar(id, "void", "function");
                // CAMBIAR ESTA LÍNEA:
                RESULT = new Node(id, new Node("void", "Leaf", "void"), pg, "func_decl");
              :}
            ;

  main_block ::= VOID MAIN LPAREN params RPAREN LKEY program:pg RKEY
                  {: RESULT = pg; :}
                ;

  program ::= expr_dcl_list:edl
              {: RESULT = edl; :}
            | /* empty */
            ;

  params ::= tipo:tp ID:id COMA params
            | tipo:tp ID:id
            | /* empty */
            ;

  declaracion ::= tipo:tp ID:id SEMI
                  {: RESULT = new Node("=", new Node(id, "Leaf", tp), null, "Declaration" ); :}
                | tipo:tp ID:id EQUAL valor:vl SEMI
                  {: RESULT = new Node("=", new Node(id, "Leaf",  tp), vl, "Declaration" ); :}
                ;

  asignacion ::= ID:id EQUAL valor:vl SEMI
                {: RESULT = new Node("=", new Node(id, "VarOP"), vl, "Asignacion" ); :}
                ;

  valor ::= expr:ex
          {: RESULT = ex; :} 
          | BOOLEAN_LIT:bl 
          {: RESULT = new Node(bl.toString(), "Leaf", "boolean"); :} 
          | func_call:fc
          {: RESULT = fc; :}
          ;

  func_call ::= ID:id LPAREN arg_list:al RPAREN
                {: RESULT = new Node(id, al, null, "func_call"); :}
              | ID:id LPAREN RPAREN
                {: RESULT = new Node(id, null, null, "func_call"); :}
              ;

  arg_list ::= arg_list:al COMA expr:ex
               {: RESULT = new Node(null, al, ex, "args"); :}
             | expr:ex
               {: RESULT = ex; :}
             ;

  tipo ::= INT {: RESULT = "int"; :}
          | FLOAT {: RESULT = "float"; :} 
          | STRING {: RESULT = "string"; :} 
          | BOOLEAN {: RESULT = "boolean"; :}
          ;

  statement ::= if_statement:is
              {: RESULT = is; :}
              |
              while_statement:ws
              {: RESULT = ws; :}
              |
              return_statement:rs
              {: RESULT = rs; :}
              ;

  return_statement ::= RETURN valor:vl SEMI
                      {: RESULT = new Node("return", vl, null, "return"); :}
                    | RETURN SEMI
                      {: RESULT = new Node("return", null, null, "return"); :}
                    ;

  if_statement ::= IF LPAREN condicion:cd RPAREN LKEY program:pg RKEY
                  {: RESULT = new Node(null, cd, pg, "if"); :}
                  |
                  IF LPAREN condicion:cd RPAREN LKEY program:pg RKEY ELSE LKEY program:pgelse RKEY
                  {:
                  Node ifNode = new Node(null, cd, pg, "if");
                  Node elseNode = new Node(null, null, pgelse, "else");
                  RESULT = new Node(null, ifNode, elseNode, "ifelse"); :}
                  ;

  while_statement ::= WHILE LPAREN condicion:cd RPAREN LKEY program:pg RKEY
                      {: RESULT = new Node(null, cd, pg, "while"); :};

  condicion ::= condicion:c1 OR condicion:c2
                {: RESULT = new Node("OR", c1, c2, "OR"); :}
            |
            condicion:c1 AND condicion:c2
                {: RESULT = new Node("AND", c1, c2, "AND"); :}
            |
            expr:ex0 comparison_expr:ce expr:ex1
                {: RESULT = new Node(ce, ex0, ex1, "condition"); :}
            ;

  comparison_expr ::= GREATER
                      {: RESULT = ">"; :}
                    | LESS
                      {: RESULT = "<"; :}
                    | DOUBLEEQUAL
                      {: RESULT = "=="; :}
                    | NOTEQUAL
                      {: RESULT = "!="; :}
                    | LESSEQUAL
                      {: RESULT = "<="; :}
                    | GREATEREQUAL
                    {: RESULT = ">="; :}
                    ;

  expr_dcl_list ::= expr_dcl_list:edl declaracion:dcl
                    {: RESULT = new Node(null, edl, dcl, "expr"); :}
                  |
                  expr_dcl_list:edl asignacion:asg
                    {: RESULT = new Node(null, edl, asg, "expr"); :}
                  | expr_dcl_list:edl statement:st
                    {: RESULT = new Node(null, edl, st, "expr"); :}
                  | declaracion:dcl
                  {: RESULT = dcl; :}
                  | asignacion:asg
                  {: RESULT = asg; :}
                  | statement:st
                  {: RESULT = st; :}
                  ;

  expr_part ::= expr:ex SEMI
                {: RESULT = ex; :}
              ;

  expr ::= expr:ex0 PLUS expr:ex1
            {: RESULT = new Node("+", ex0, ex1, "Operation"); :}
        | expr:ex0 MINUS expr:ex1
            {: RESULT = new Node("-", ex0, ex1, "Operation"); :}
        | expr:ex0 TIMES expr:ex1
            {: RESULT = new Node("*", ex0, ex1, "Operation"); :}
        | expr:ex0 DIVIDE expr:ex1
            {: RESULT = new Node("/", ex0, ex1, "Operation"); :}
        | LPAREN expr:ex RPAREN
            {: RESULT = ex; :}
        | NUMBER:number
            {: RESULT = new Node(number.toString(), "Leaf", "int"); :}
        | FLOATNUM:f
          {: RESULT = new Node(f.toString(), "Leaf", "float"); :}
        | ID:id
          {: RESULT = new Node(id, "VarOP"); :}
        ;